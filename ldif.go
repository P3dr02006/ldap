package ldap

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	// "os"
	"strconv"
)

// A basic LDIF parser. This one does currently just support LDIFs like
// they're generated by tools like ldapsearch(1) / slapcat(8). Change
// records are not supported.
type LDIF struct {
	RelaxedParser bool // ignore parsing errors in a line
	Entries       []*Entry
	curLine       int
	version       int
	changeType    string
}

var CR byte = '\x0D'
var LF byte = '\x0A'
var SEP string = string([]byte{CR, LF})
var Comment byte = '#'
var SPACE byte = ' '
var SPACES = string(SPACE)

func (l *LDIF) newError(msg string) error {
	return errors.New(fmt.Sprintf("error on line %d: %s\n", l.curLine, msg))
}

// Parses the LDIF, the caller is responsible for closing the io.Reader if that's
// needed. This Parser may be called several times with different io.Readers to
// combine the files.
func (l *LDIF) Parse(r io.Reader) (err error) {
	if r == nil {
		return errors.New("No reader present")
	}
	reader := bufio.NewReader(r)
	l.curLine = 0
	l.changeType = ""
	l.version = 0

	var lines [][]byte
	var line, nextLine []byte

	for {
		l.curLine++
		nextLine, err = reader.ReadBytes(LF)
		nextLine = bytes.TrimRight(nextLine, SEP)
		// fmt.Fprintf(os.Stderr, "NEXT=>%s<\n", nextLine)
		switch err {
		case nil, io.EOF:
			switch len(nextLine) {
			case 0:
				if len(line) == 0 && err == io.EOF {
					return nil
				}
				lines = append(lines, line)
				entry, perr := l.parseEntry(lines)
				if perr != nil {
					if !l.RelaxedParser {
						return l.newError(perr.Error())
					}
				}
				l.Entries = append(l.Entries, entry)
				line = []byte{}
				lines = [][]byte{}
				if err == io.EOF {
					return nil
				}
			default:
				switch nextLine[0] {
				case Comment:
					continue
				case SPACE:
					if len(nextLine) > 1 {
						line = append(line, nextLine[1:]...)
						continue
					} else {
						return l.newError("space only line")
					}
				default:
					if len(line) != 0 {
						lines = append(lines, line)
					}
					line = nextLine
					continue
				}
			}
		default:
			return l.newError(err.Error())
		}
	}
	if len(lines) != 0 {
		entry, perr := l.parseEntry(lines)
		if perr != nil {
			return l.newError(perr.Error())
		}
		l.Entries = append(l.Entries, entry)
	}
	return nil
}

func (l *LDIF) parseEntry(lines [][]byte) (entry *Entry, err error) {
	// for i, line := range lines {
	//     fmt.Fprintf(os.Stderr, "% 2d %s\n", i, line)
	// }
	if l.version == 0 && bytes.HasPrefix(lines[0], []byte("version:")) {
		line := bytes.TrimLeft(lines[0][8:], SPACES)
		if version, err := strconv.Atoi(string(line)); err != nil {
			return nil, err
		} else {
			if version != 1 {
				return nil, errors.New("Invalid version spec " + string(line))
			}
			l.version = 1
			lines = lines[1:]
		}
	}

	if !bytes.HasPrefix(lines[0], []byte("dn:")) {
		return nil, errors.New("Missing dn:")
	}
	_, val, err := l.parseLine(lines[0])
	if err != nil {
		return nil, err
	}
	dn := val

	lines = lines[1:]
	if bytes.HasPrefix(lines[0], []byte("changetype:")) {
		_, val, err := l.parseLine(lines[0])
		if err != nil {
			return nil, err
		}
		l.changeType = val
		lines = lines[1:]
	}
	if l.changeType != "" {
		return nil, errors.New("change records not supported")
	}

	attrs := make(map[string][]string)
	for i := 0; i < len(lines); i++ {
		attr, val, err := l.parseLine(lines[i])
		if err != nil {
			if !l.RelaxedParser {
				return nil, err
			} else {
				continue
			}
		}
		if _, ok := attrs[attr]; ok {
			attrs[attr] = append(attrs[attr], string(val))
		} else {
			attrs[attr] = []string{string(val)}
		}
	}
	return NewEntry(dn, attrs), nil
}

func (l *LDIF) parseLine(line []byte) (attr, val string, err error) {
	off := 0
	for len(line) > off && line[off] != ':' {
		off++
		if off >= len(line) {
			return
		}
	}
	if off == len(line) {
		err = errors.New("Missing : in line")
		return
	}
	if off > len(line)-2 {
		err = errors.New("empty value")
		return
	}

	attr = string(line[0:off])
	if err = validAttr(attr); err != nil {
		attr = ""
		val = ""
		return
	}

	switch line[off+1] {
	case ':':
		var n int
		value := bytes.TrimLeft(line[off+2:], SPACES)
		// fmt.Fprintf(os.Stderr, "LINE=%s\nVALUE=%s\n", line, value)
		dec := make([]byte, base64.StdEncoding.DecodedLen(len(value)))
		n, err = base64.StdEncoding.Decode(dec, value)
		if err != nil {
			return
		}
		val = string(dec[:n])
	case '<': // FIXME missing return for *net.URL type
		val = string(bytes.TrimLeft(line[off+2:], SPACES))
	default:
		val = string(bytes.TrimLeft(line[off+2:], SPACES))
	}

	return
}

func validOID(oid string) error {
	lastDot := true
	for _, c := range oid {
		switch {
		case c == '.' && lastDot:
			return errors.New("OID with at least 2 consecutive dots")
		case c == '.':
			lastDot = true
		case c >= 0x30 && c <= 0x39:
			lastDot = false
		default:
			return errors.New("Invalid character in OID")
		}
	}
	return nil
}

func validAttr(attr string) error {
	if len(attr) == 0 {
		return errors.New("empty attribute name")
	}
	switch {
	case attr[0] >= 0x41 && attr[0] <= 0x5A:
		// A-Z
	case attr[0] >= 0x61 && attr[0] <= 0x7A:
		// a-z
	default:
		if attr[0] >= 0x30 && attr[0] <= 0x39 {
			return validOID(attr)
		}
		return errors.New("invalid first character in attribute")
	}
	for i := 1; i < len(attr); i++ {
		c := attr[i]
		switch {
		case c >= 0x30 && c <= 0x39:
		case c >= 0x41 && c <= 0x5A:
		case c >= 0x61 && c <= 0x7A:
		case c == '-':
		case c == ';':
		default:
			return errors.New("invalid character in attribute name")
		}
	}
	return nil
}
